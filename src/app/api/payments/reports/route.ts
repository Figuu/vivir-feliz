import { NextRequest, NextResponse } from 'next/server'
import { PaymentAnalyticsManager, ReportType } from '@/lib/payment-analytics-manager'
import { z } from 'zod'

const generateReportSchema = z.object({
  reportType: z.enum(['DAILY', 'WEEKLY', 'MONTHLY', 'QUARTERLY', 'YEARLY', 'CUSTOM']),
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  generatedBy: z.string().min(1, 'Generated by is required')
})

const getReportsQuerySchema = z.object({
  reportType: z.enum(['DAILY', 'WEEKLY', 'MONTHLY', 'QUARTERLY', 'YEARLY', 'CUSTOM']).optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  generatedBy: z.string().optional(),
  page: z.string().optional().transform(val => val ? parseInt(val) : 1),
  limit: z.string().optional().transform(val => val ? Math.min(parseInt(val), 100) : 20)
})

// POST - Generate financial report
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validate request body
    const validationResult = generateReportSchema.safeParse(body)
    if (!validationResult.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Validation failed',
          details: validationResult.error.flatten().fieldErrors
        },
        { status: 400 }
      )
    }
    
    const { reportType, startDate, endDate, generatedBy } = validationResult.data
    
    // Generate financial report
    const report = await PaymentAnalyticsManager.generateFinancialReport(
      reportType,
      { start: new Date(startDate), end: new Date(endDate) },
      generatedBy
    )
    
    return NextResponse.json({
      success: true,
      data: report,
      message: 'Financial report generated successfully'
    }, { status: 201 })
    
  } catch (error) {
    console.error('Error generating financial report:', error)
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to generate financial report' 
      },
      { status: 500 }
    )
  }
}

// GET - Get financial reports
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    
    // Parse and validate query parameters
    const queryParams = Object.fromEntries(searchParams.entries())
    const validationResult = getReportsQuerySchema.safeParse(queryParams)
    
    if (!validationResult.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Invalid query parameters',
          details: validationResult.error.flatten().fieldErrors
        },
        { status: 400 }
      )
    }
    
    const { reportType, startDate, endDate, generatedBy, page, limit } = validationResult.data
    
    // In a real implementation, you would fetch reports from database
    // For now, return mock data
    const mockReports = [
      {
        id: 'report_1',
        reportType: 'MONTHLY',
        period: {
          start: new Date('2024-01-01'),
          end: new Date('2024-01-31')
        },
        generatedAt: new Date('2024-02-01'),
        generatedBy: 'system',
        summary: {
          totalRevenue: 50000,
          totalPayments: 150,
          averagePayment: 333.33,
          growthRate: 12.5,
          topPerformingTherapist: 'Dr. Smith',
          topService: 'Individual Therapy'
        }
      }
    ]
    
    // Apply filters
    let filteredReports = mockReports
    
    if (reportType) {
      filteredReports = filteredReports.filter(report => report.reportType === reportType)
    }
    
    if (startDate && endDate) {
      const start = new Date(startDate)
      const end = new Date(endDate)
      filteredReports = filteredReports.filter(report => 
        report.period.start >= start && report.period.end <= end
      )
    }
    
    if (generatedBy) {
      filteredReports = filteredReports.filter(report => report.generatedBy === generatedBy)
    }
    
    // Apply pagination
    const offset = (page - 1) * limit
    const paginatedReports = filteredReports.slice(offset, offset + limit)
    
    return NextResponse.json({
      success: true,
      data: {
        reports: paginatedReports,
        totalCount: filteredReports.length,
        pagination: {
          page,
          limit,
          totalPages: Math.ceil(filteredReports.length / limit),
          hasNextPage: page < Math.ceil(filteredReports.length / limit),
          hasPrevPage: page > 1
        }
      }
    })
    
  } catch (error) {
    console.error('Error getting financial reports:', error)
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to get financial reports' 
      },
      { status: 500 }
    )
  }
}