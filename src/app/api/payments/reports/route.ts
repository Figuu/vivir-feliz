import { NextRequest, NextResponse } from 'next/server'
import { PaymentAnalyticsManager, ReportType } from '@/lib/payment-analytics-manager'
import { z } from 'zod'

const generateReportSchema = z.object({
  reportType: z.enum(['DAILY', 'WEEKLY', 'MONTHLY', 'QUARTERLY', 'YEARLY', 'CUSTOM']),
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  generatedBy: z.string().min(1, 'Generated by is required')
})

const getReportsQuerySchema = z.object({
  reportType: z.enum(['DAILY', 'WEEKLY', 'MONTHLY', 'QUARTERLY', 'YEARLY', 'CUSTOM']).optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  generatedBy: z.string().optional(),
  page: z.string().optional().transform(val => val ? parseInt(val) : 1),
  limit: z.string().optional().transform(val => val ? Math.min(parseInt(val), 100) : 20)
})

// POST - Generate financial report
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validate request body
    const validationResult = generateReportSchema.safeParse(body)
    if (!validationResult.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Validation failed',
          details: validationResult.error.flatten().fieldErrors
        },
        { status: 400 }
      )
    }
    
    const { reportType, startDate, endDate, generatedBy } = validationResult.data
    
    // Generate financial report
    const report = await PaymentAnalyticsManager.generateFinancialReport(
      reportType,
      { start: new Date(startDate), end: new Date(endDate) },
      generatedBy
    )
    
    return NextResponse.json({
      success: true,
      data: report,
      message: 'Financial report generated successfully'
    }, { status: 201 })
    
  } catch (error) {
    console.error('Error generating financial report:', error)
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to generate financial report' 
      },
      { status: 500 }
    )
  }
}

// GET - Get financial reports
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    
    // Parse and validate query parameters
    const queryParams = Object.fromEntries(searchParams.entries())
    const validationResult = getReportsQuerySchema.safeParse(queryParams)
    
    if (!validationResult.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Invalid query parameters',
          details: validationResult.error.flatten().fieldErrors
        },
        { status: 400 }
      )
    }
    
    const { reportType, startDate, endDate, generatedBy, page, limit } = validationResult.data
    
    // Fetch payment data from database for the specified period
    const where: any = {}
    
    if (startDate) {
      where.createdAt = { ...where.createdAt, gte: new Date(startDate) }
    }
    if (endDate) {
      where.createdAt = { ...where.createdAt, lte: new Date(endDate) }
    }
    
    const payments = await db.payment.findMany({
      where,
      include: {
        parent: {
          select: {
            firstName: true,
            lastName: true
          }
        },
        consultationRequest: {
          select: {
            id: true,
            type: true
          }
        },
        therapeuticProposal: {
          select: {
            id: true,
            therapist: {
              select: {
                firstName: true,
                lastName: true
              }
            }
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
    
    // Calculate report statistics
    const totalRevenue = payments
      .filter(p => p.status === 'CONFIRMED')
      .reduce((sum, p) => sum + Number(p.amount), 0)
    const totalPayments = payments.filter(p => p.status === 'CONFIRMED').length
    const averagePayment = totalPayments > 0 ? totalRevenue / totalPayments : 0
    
    const reports = [{
      id: `report_${Date.now()}`,
      reportType: reportType || 'CUSTOM',
      period: {
        start: startDate ? new Date(startDate) : new Date(),
        end: endDate ? new Date(endDate) : new Date()
      },
      generatedAt: new Date(),
      generatedBy: generatedBy || 'system',
      summary: {
        totalRevenue,
        totalPayments,
        averagePayment,
        confirmedPayments: payments.filter(p => p.status === 'CONFIRMED').length,
        pendingPayments: payments.filter(p => p.status === 'PENDING').length
      },
      payments: payments.slice((page - 1) * limit, page * limit)
    }]
    
    // Apply filters to real reports from database
    let filteredReports = reports
    
    if (reportType) {
      filteredReports = filteredReports.filter(report => report.reportType === reportType)
    }
    
    if (startDate && endDate) {
      const start = new Date(startDate)
      const end = new Date(endDate)
      filteredReports = filteredReports.filter(report => 
        report.period.start >= start && report.period.end <= end
      )
    }
    
    if (generatedBy) {
      filteredReports = filteredReports.filter(report => report.generatedBy === generatedBy)
    }
    
    // Apply pagination
    const offset = (page - 1) * limit
    const paginatedReports = filteredReports.slice(offset, offset + limit)
    
    return NextResponse.json({
      success: true,
      data: {
        reports: paginatedReports,
        totalCount: filteredReports.length,
        pagination: {
          page,
          limit,
          totalPages: Math.ceil(filteredReports.length / limit),
          hasNextPage: page < Math.ceil(filteredReports.length / limit),
          hasPrevPage: page > 1
        }
      }
    })
    
  } catch (error) {
    console.error('Error getting financial reports:', error)
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to get financial reports' 
      },
      { status: 500 }
    )
  }
}