import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { db } from '@/lib/db'
import { jsPDF } from 'jspdf'
import 'jspdf-autotable'

// Extend jsPDF type to include autoTable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF
  }
}

// Comprehensive validation schemas
const pdfGenerationSchema = z.object({
  // Report Configuration
  reportType: z.enum(['summary', 'detailed', 'analytics', 'milestone', 'progress_timeline', 'risk_assessment']),
  
  // Data Selection
  patientId: z.string().uuid('Invalid patient ID'),
  therapistId: z.string().uuid('Invalid therapist ID').optional(),
  
  // Date Range
  startDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Start date must be in YYYY-MM-DD format')
    .transform(val => new Date(val)),
  
  endDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'End date must be in YYYY-MM-DD format')
    .transform(val => new Date(val)),
  
  // Report Options
  options: z.object({
    includeCharts: z.boolean().default(true),
    includeProgressData: z.boolean().default(true),
    includeRiskAssessment: z.boolean().default(true),
    includeGoals: z.boolean().default(true),
    includeRecommendations: z.boolean().default(true),
    includeSessionDetails: z.boolean().default(false),
    includeAnalytics: z.boolean().default(true),
    includeTimeline: z.boolean().default(true),
    includeMilestones: z.boolean().default(true),
    includeValidationStatus: z.boolean().default(true),
    includeNotes: z.boolean().default(true),
    includeTags: z.boolean().default(false),
    pageOrientation: z.enum(['portrait', 'landscape']).default('portrait'),
    fontSize: z.number().min(8).max(16).default(12),
    includeHeader: z.boolean().default(true),
    includeFooter: z.boolean().default(true),
    includeTableOfContents: z.boolean().default(true),
    includeExecutiveSummary: z.boolean().default(true)
  }).optional().default({}),
  
  // Customization
  customization: z.object({
    title: z.string().max(200, 'Title cannot exceed 200 characters').optional(),
    subtitle: z.string().max(300, 'Subtitle cannot exceed 300 characters').optional(),
    logoUrl: z.string().url('Invalid logo URL').optional(),
    organizationName: z.string().max(100, 'Organization name cannot exceed 100 characters').optional(),
    therapistName: z.string().max(100, 'Therapist name cannot exceed 100 characters').optional(),
    patientName: z.string().max(100, 'Patient name cannot exceed 100 characters').optional(),
    reportDate: z.string()
      .regex(/^\d{4}-\d{2}-\d{2}$/, 'Report date must be in YYYY-MM-DD format')
      .transform(val => new Date(val))
      .optional(),
    confidentialityNotice: z.string().max(500, 'Confidentiality notice cannot exceed 500 characters').optional(),
    footerText: z.string().max(200, 'Footer text cannot exceed 200 characters').optional()
  }).optional().default({}),
  
  // Generated by
  generatedBy: z.string().uuid('Invalid generator ID')
})

// POST /api/progress-reports/pdf - Generate progress report PDF
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validate request body
    const validation = pdfGenerationSchema.safeParse(body)
    if (!validation.success) {
      return NextResponse.json(
        { error: 'Invalid request data', details: validation.error.issues },
        { status: 400 }
      )
    }

    const validatedData = validation.data

    // Check if patient exists
    const patient = await db.patient.findUnique({
      where: { id: validatedData.patientId },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    })

    if (!patient) {
      return NextResponse.json(
        { error: 'Patient not found' },
        { status: 404 }
      )
    }

    // Check if therapist exists (if provided)
    let therapist = null
    if (validatedData.therapistId) {
      therapist = await db.therapist.findUnique({
        where: { id: validatedData.therapistId },
        include: {
          user: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      })

      if (!therapist) {
        return NextResponse.json(
          { error: 'Therapist not found' },
          { status: 404 }
        )
      }
    }

    // Check if generator exists
    const generator = await db.user.findUnique({
      where: { id: validatedData.generatedBy }
    })

    if (!generator) {
      return NextResponse.json(
        { error: 'Generator not found' },
        { status: 404 }
      )
    }

    // Fetch progress data based on report type
    const progressData = await fetchProgressData(validatedData)
    
    // Generate PDF
    const pdfBuffer = await generateProgressReportPDF(validatedData, progressData, patient, therapist, generator)

    // Return PDF as response
    return new NextResponse(pdfBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="progress-report-${patient.user.firstName}-${patient.user.lastName}-${new Date().toISOString().split('T')[0]}.pdf"`,
        'Content-Length': pdfBuffer.length.toString()
      }
    })

  } catch (error) {
    console.error('Error generating progress report PDF:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// Helper function to fetch progress data
async function fetchProgressData(params: any) {
  const whereClause: any = {
    patientId: params.patientId,
    entryDate: {
      gte: params.startDate,
      lte: params.endDate
    }
  }

  if (params.therapistId) {
    whereClause.therapistId = params.therapistId
  }

  // Fetch progress entries
  const progressEntries = await db.patientProgress.findMany({
    where: whereClause,
    include: {
      patient: {
        include: {
          user: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      },
      therapist: {
        include: {
          user: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      },
      createdByUser: {
        select: {
          firstName: true,
          lastName: true,
          email: true
        }
      }
    },
    orderBy: { entryDate: 'asc' }
  })

  // Fetch milestones if needed
  let milestones = []
  if (params.options.includeMilestones) {
    milestones = await db.progressMilestone.findMany({
      where: {
        patientId: params.patientId,
        targetDate: {
          gte: params.startDate,
          lte: params.endDate
        }
      },
      include: {
        patient: {
          include: {
            user: {
              select: {
                firstName: true,
                lastName: true
              }
            }
          }
        },
        therapist: {
          include: {
            user: {
              select: {
                firstName: true,
                lastName: true
              }
            }
          }
        }
      },
      orderBy: { targetDate: 'asc' }
    })
  }

  // Calculate analytics if needed
  let analytics = null
  if (params.options.includeAnalytics) {
    analytics = calculateProgressAnalytics(progressEntries)
  }

  return {
    progressEntries,
    milestones,
    analytics
  }
}

// Helper function to calculate progress analytics
function calculateProgressAnalytics(progressEntries: any[]) {
  if (progressEntries.length === 0) {
    return {
      totalEntries: 0,
      averageProgress: 0,
      progressTrend: 'stable',
      riskLevel: 'low',
      completionRate: 0
    }
  }

  const totalEntries = progressEntries.length
  const averageProgress = progressEntries.reduce((sum, entry) => sum + entry.overallProgress, 0) / totalEntries
  
  // Calculate progress trend
  const firstHalf = progressEntries.slice(0, Math.floor(totalEntries / 2))
  const secondHalf = progressEntries.slice(Math.floor(totalEntries / 2))
  
  const firstHalfAvg = firstHalf.reduce((sum, entry) => sum + entry.overallProgress, 0) / firstHalf.length
  const secondHalfAvg = secondHalf.reduce((sum, entry) => sum + entry.overallProgress, 0) / secondHalf.length
  
  let progressTrend = 'stable'
  if (secondHalfAvg > firstHalfAvg + 5) {
    progressTrend = 'improving'
  } else if (secondHalfAvg < firstHalfAvg - 5) {
    progressTrend = 'declining'
  }

  // Calculate risk level
  const highRiskEntries = progressEntries.filter(entry => 
    entry.riskAssessment && entry.riskAssessment.riskLevel === 'high'
  ).length
  
  const criticalRiskEntries = progressEntries.filter(entry => 
    entry.riskAssessment && entry.riskAssessment.riskLevel === 'critical'
  ).length
  
  let riskLevel = 'low'
  if (criticalRiskEntries > 0) {
    riskLevel = 'critical'
  } else if (highRiskEntries > totalEntries * 0.3) {
    riskLevel = 'high'
  } else if (highRiskEntries > 0) {
    riskLevel = 'moderate'
  }

  // Calculate completion rate
  const completedGoals = progressEntries.reduce((sum, entry) => {
    if (entry.goalsProgress) {
      return sum + entry.goalsProgress.filter((goal: any) => goal.status === 'completed').length
    }
    return sum
  }, 0)
  
  const totalGoals = progressEntries.reduce((sum, entry) => {
    if (entry.goalsProgress) {
      return sum + entry.goalsProgress.length
    }
    return sum
  }, 0)
  
  const completionRate = totalGoals > 0 ? (completedGoals / totalGoals) * 100 : 0

  return {
    totalEntries,
    averageProgress: Math.round(averageProgress * 10) / 10,
    progressTrend,
    riskLevel,
    completionRate: Math.round(completionRate * 10) / 10,
    highRiskEntries,
    criticalRiskEntries,
    completedGoals,
    totalGoals
  }
}

// Helper function to generate PDF
async function generateProgressReportPDF(
  params: any,
  data: any,
  patient: any,
  therapist: any,
  generator: any
) {
  const doc = new jsPDF({
    orientation: params.options.pageOrientation,
    unit: 'mm',
    format: 'a4'
  })

  const pageWidth = doc.internal.pageSize.getWidth()
  const pageHeight = doc.internal.pageSize.getHeight()
  const margin = 20
  const contentWidth = pageWidth - (margin * 2)
  let currentY = margin

  // Helper function to add text with word wrap
  const addText = (text: string, x: number, y: number, options: any = {}) => {
    const { fontSize = 12, fontStyle = 'normal', color = '#000000', maxWidth = contentWidth } = options
    doc.setFontSize(fontSize)
    doc.setFont('helvetica', fontStyle)
    doc.setTextColor(color)
    
    const lines = doc.splitTextToSize(text, maxWidth)
    doc.text(lines, x, y)
    return y + (lines.length * fontSize * 0.4)
  }

  // Helper function to add a new page if needed
  const checkNewPage = (requiredSpace: number) => {
    if (currentY + requiredSpace > pageHeight - margin) {
      doc.addPage()
      currentY = margin
      return true
    }
    return false
  }

  // Header
  if (params.options.includeHeader) {
    // Title
    const title = params.customization.title || `${params.reportType.charAt(0).toUpperCase() + params.reportType.slice(1)} Progress Report`
    currentY = addText(title, margin, currentY, { fontSize: 18, fontStyle: 'bold' }) + 5

    // Subtitle
    if (params.customization.subtitle) {
      currentY = addText(params.customization.subtitle, margin, currentY, { fontSize: 12, color: '#666666' }) + 5
    }

    // Patient and Therapist Info
    const patientName = `${patient.user.firstName} ${patient.user.lastName}`
    const therapistName = therapist ? `${therapist.user.firstName} ${therapist.user.lastName}` : 'Multiple Therapists'
    const reportDate = params.customization.reportDate || new Date()
    
    currentY = addText(`Patient: ${patientName}`, margin, currentY, { fontSize: 12, fontStyle: 'bold' }) + 2
    currentY = addText(`Therapist: ${therapistName}`, margin, currentY, { fontSize: 12 }) + 2
    currentY = addText(`Report Date: ${reportDate.toLocaleDateString()}`, margin, currentY, { fontSize: 12 }) + 2
    currentY = addText(`Period: ${params.startDate.toLocaleDateString()} - ${params.endDate.toLocaleDateString()}`, margin, currentY, { fontSize: 12 }) + 10

    // Line separator
    doc.setDrawColor(200, 200, 200)
    doc.line(margin, currentY, pageWidth - margin, currentY)
    currentY += 10
  }

  // Executive Summary
  if (params.options.includeExecutiveSummary && data.analytics) {
    checkNewPage(50)
    currentY = addText('Executive Summary', margin, currentY, { fontSize: 16, fontStyle: 'bold' }) + 5
    
    const summaryText = `This report covers ${data.analytics.totalEntries} progress entries over the specified period. ` +
      `The patient's average progress is ${data.analytics.averageProgress}% with a ${data.analytics.progressTrend} trend. ` +
      `The overall risk level is ${data.analytics.riskLevel} with a goal completion rate of ${data.analytics.completionRate}%.`
    
    currentY = addText(summaryText, margin, currentY, { fontSize: 11 }) + 10
  }

  // Progress Overview
  if (params.options.includeProgressData) {
    checkNewPage(100)
    currentY = addText('Progress Overview', margin, currentY, { fontSize: 16, fontStyle: 'bold' }) + 5

    // Progress entries table
    const tableData = data.progressEntries.map((entry: any) => [
      entry.entryDate.toLocaleDateString(),
      entry.entryType,
      entry.title,
      `${entry.overallProgress}%`,
      entry.validationStatus
    ])

    doc.autoTable({
      startY: currentY,
      head: [['Date', 'Type', 'Title', 'Progress', 'Status']],
      body: tableData,
      styles: { fontSize: 9 },
      headStyles: { fillColor: [66, 139, 202] },
      margin: { left: margin, right: margin }
    })

    currentY = (doc as any).lastAutoTable.finalY + 10
  }

  // Risk Assessment
  if (params.options.includeRiskAssessment) {
    checkNewPage(80)
    currentY = addText('Risk Assessment', margin, currentY, { fontSize: 16, fontStyle: 'bold' }) + 5

    const riskEntries = data.progressEntries.filter((entry: any) => entry.riskAssessment)
    
    if (riskEntries.length > 0) {
      const riskData = riskEntries.map((entry: any) => [
        entry.entryDate.toLocaleDateString(),
        entry.riskAssessment.riskLevel,
        entry.riskAssessment.riskFactors.join(', ') || 'None',
        entry.riskAssessment.crisisIntervention ? 'Yes' : 'No'
      ])

      doc.autoTable({
        startY: currentY,
        head: [['Date', 'Risk Level', 'Risk Factors', 'Crisis Intervention']],
        body: riskData,
        styles: { fontSize: 9 },
        headStyles: { fillColor: [220, 53, 69] },
        margin: { left: margin, right: margin }
      })

      currentY = (doc as any).lastAutoTable.finalY + 10
    } else {
      currentY = addText('No risk assessment data available for the specified period.', margin, currentY, { fontSize: 11, color: '#666666' }) + 5
    }
  }

  // Goals Progress
  if (params.options.includeGoals) {
    checkNewPage(80)
    currentY = addText('Goals Progress', margin, currentY, { fontSize: 16, fontStyle: 'bold' }) + 5

    const allGoals = data.progressEntries.flatMap((entry: any) => 
      entry.goalsProgress ? entry.goalsProgress.map((goal: any) => ({
        ...goal,
        entryDate: entry.entryDate
      })) : []
    )

    if (allGoals.length > 0) {
      const goalData = allGoals.map((goal: any) => [
        goal.entryDate.toLocaleDateString(),
        goal.goalTitle,
        `${goal.progressPercentage}%`,
        goal.status
      ])

      doc.autoTable({
        startY: currentY,
        head: [['Date', 'Goal', 'Progress', 'Status']],
        body: goalData,
        styles: { fontSize: 9 },
        headStyles: { fillColor: [40, 167, 69] },
        margin: { left: margin, right: margin }
      })

      currentY = (doc as any).lastAutoTable.finalY + 10
    } else {
      currentY = addText('No goals data available for the specified period.', margin, currentY, { fontSize: 11, color: '#666666' }) + 5
    }
  }

  // Recommendations
  if (params.options.includeRecommendations) {
    checkNewPage(80)
    currentY = addText('Recommendations', margin, currentY, { fontSize: 16, fontStyle: 'bold' }) + 5

    const allRecommendations = data.progressEntries.flatMap((entry: any) => 
      entry.recommendations ? entry.recommendations.map((rec: any) => ({
        ...rec,
        entryDate: entry.entryDate
      })) : []
    )

    if (allRecommendations.length > 0) {
      const recData = allRecommendations.map((rec: any) => [
        rec.entryDate.toLocaleDateString(),
        rec.type,
        rec.description,
        rec.priority,
        rec.isCompleted ? 'Yes' : 'No'
      ])

      doc.autoTable({
        startY: currentY,
        head: [['Date', 'Type', 'Description', 'Priority', 'Completed']],
        body: recData,
        styles: { fontSize: 9 },
        headStyles: { fillColor: [255, 193, 7] },
        margin: { left: margin, right: margin }
      })

      currentY = (doc as any).lastAutoTable.finalY + 10
    } else {
      currentY = addText('No recommendations available for the specified period.', margin, currentY, { fontSize: 11, color: '#666666' }) + 5
    }
  }

  // Milestones
  if (params.options.includeMilestones && data.milestones.length > 0) {
    checkNewPage(80)
    currentY = addText('Milestones', margin, currentY, { fontSize: 16, fontStyle: 'bold' }) + 5

    const milestoneData = data.milestones.map((milestone: any) => [
      milestone.targetDate.toLocaleDateString(),
      milestone.title,
      milestone.type,
      `${milestone.progress}%`,
      milestone.status
    ])

    doc.autoTable({
      startY: currentY,
      head: [['Target Date', 'Title', 'Type', 'Progress', 'Status']],
      body: milestoneData,
      styles: { fontSize: 9 },
      headStyles: { fillColor: [111, 66, 193] },
      margin: { left: margin, right: margin }
    })

    currentY = (doc as any).lastAutoTable.finalY + 10
  }

  // Analytics
  if (params.options.includeAnalytics && data.analytics) {
    checkNewPage(60)
    currentY = addText('Analytics Summary', margin, currentY, { fontSize: 16, fontStyle: 'bold' }) + 5

    const analyticsData = [
      ['Total Entries', data.analytics.totalEntries.toString()],
      ['Average Progress', `${data.analytics.averageProgress}%`],
      ['Progress Trend', data.analytics.progressTrend],
      ['Risk Level', data.analytics.riskLevel],
      ['Goal Completion Rate', `${data.analytics.completionRate}%`],
      ['High Risk Entries', data.analytics.highRiskEntries.toString()],
      ['Critical Risk Entries', data.analytics.criticalRiskEntries.toString()],
      ['Completed Goals', data.analytics.completedGoals.toString()],
      ['Total Goals', data.analytics.totalGoals.toString()]
    ]

    doc.autoTable({
      startY: currentY,
      head: [['Metric', 'Value']],
      body: analyticsData,
      styles: { fontSize: 10 },
      headStyles: { fillColor: [52, 58, 64] },
      margin: { left: margin, right: margin }
    })

    currentY = (doc as any).lastAutoTable.finalY + 10
  }

  // Footer
  if (params.options.includeFooter) {
    const footerText = params.customization.footerText || 
      `Generated on ${new Date().toLocaleDateString()} by ${generator.firstName} ${generator.lastName}`
    
    doc.setFontSize(8)
    doc.setTextColor(128, 128, 128)
    doc.text(footerText, margin, pageHeight - 10)
    
    // Page numbers
    const pageCount = doc.getNumberOfPages()
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i)
      doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin - 20, pageHeight - 10)
    }
  }

  // Confidentiality Notice
  if (params.customization.confidentialityNotice) {
    checkNewPage(30)
    currentY = addText('Confidentiality Notice', margin, currentY, { fontSize: 12, fontStyle: 'bold' }) + 3
    currentY = addText(params.customization.confidentialityNotice, margin, currentY, { fontSize: 9, color: '#666666' }) + 5
  }

  return doc.output('arraybuffer')
}
